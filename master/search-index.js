var searchIndex = {};
searchIndex["lockfreehashmap"] = {"doc":"LockFreeHashMap","items":[[5,"pin","lockfreehashmap","Pins the current thread.",null,{"inputs":[],"output":{"name":"guard"}}],[3,"Guard","","A guard that keeps the current thread pinned.",null,null],[12,"local","","",0,null],[5,"scope","","Create a new `scope`, for deferred destructors.",null,{"inputs":[{"name":"f"}],"output":{"name":"r"}}],[3,"Scope","","",null,null],[12,"dtors","","The list of the deferred functions and thread join jobs.",1,null],[12,"_marker","","",1,null],[3,"LockFreeHashMap","","",null,null],[12,"inner","","Points to the newest map (after it's been fully resized). Always non-null.",2,null],[0,"atomic","","",null,null],[3,"NotNull","lockfreehashmap::atomic","A wrapper around [Shared], for values that we know are not null and are safe to dereference.",null,null],[12,"0","","",3,null],[3,"NotNullOwned","","A wrapper around [Owned], for values that we know are not null. This is the owned version of [NotNull].",null,null],[12,"0","","",4,null],[3,"MaybeNull","","Similarly to [NotNull], this is a wrapper around [Shared] for values where the pointer could be null.",null,null],[12,"0","","",5,null],[3,"AtomicPtr","","Wrapper around [Atomic]. Represents a pointer that can be null at first but never again afterwards.",null,null],[12,"0","","",6,null],[3,"AtomicBox","","Wrapper around [Atomic]. Represents a pointer that can never be null.",null,null],[12,"0","","",7,null],[17,"ORDERING","","",null,null],[11,"as_maybe_null","","This is effectively just weakening the guarantees around this type.",3,{"inputs":[{"name":"self"}],"output":{"name":"maybenull"}}],[11,"as_shared","","",3,{"inputs":[{"name":"self"}],"output":{"name":"shared"}}],[11,"deref","","Stronger version of `Deref`.  This returns `&'t T`, rather than `&'f T`.",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","Drop the underlying value behind this pointer.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"deref","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"new","","",4,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"into_owned","","",4,{"inputs":[{"name":"self"}],"output":{"name":"owned"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"deref","","",4,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"from_shared","","",5,{"inputs":[{"name":"shared"}],"output":{"name":"self"}}],[11,"as_shared","","",5,{"inputs":[{"name":"self"}],"output":{"name":"shared"}}],[11,"as_option","","",5,{"inputs":[{"name":"self"}],"output":{"generics":["notnull"],"name":"option"}}],[11,"try_defer_drop","","Drop the underlying value behind this pointer if it's not null and after enough epochs have passed.",5,{"inputs":[{"name":"self"},{"name":"guard"}],"output":null}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",6,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"load","","",6,{"inputs":[{"name":"self"},{"name":"guard"}],"output":{"name":"maybenull"}}],[11,"relaxed_exists","","Check if the pointer is not null (i.e. the value exists), using `Ordering::Relaxed`.",6,{"inputs":[{"name":"self"},{"name":"guard"}],"output":{"name":"bool"}}],[11,"take","","Swaps out the current value, leaving null in its place. Equivalent to [Option::take()].",6,{"inputs":[{"name":"self"},{"name":"guard"}],"output":{"generics":["box"],"name":"option"}}],[11,"compare_and_set","","",6,{"inputs":[{"name":"self"},{"name":"maybenull"},{"name":"notnull"},{"name":"guard"}],"output":{"generics":["notnull"],"name":"result"}}],[11,"compare_null_and_set","","",6,{"inputs":[{"name":"self"},{"name":"notnull"},{"name":"guard"}],"output":{"generics":["notnull"],"name":"result"}}],[11,"compare_null_and_set_owned","","",6,{"inputs":[{"name":"self"},{"name":"notnullowned"},{"name":"guard"}],"output":{"generics":["notnull"],"name":"result"}}],[11,"compare_and_set_owned","","",6,{"inputs":[{"name":"self"},{"name":"maybenull"},{"name":"notnullowned"},{"name":"guard"}],"output":{"generics":["notnull"],"name":"result"}}],[11,"compare_and_set_owned_weak","","",6,{"inputs":[{"name":"self"},{"name":"maybenull"},{"name":"notnullowned"},{"name":"guard"}],"output":{"generics":["notnull"],"name":"result"}}],[11,"tag","","",6,{"inputs":[{"name":"self"},{"name":"guard"}],"output":null}],[11,"is_tagged","","",6,{"inputs":[{"name":"self"},{"name":"guard"}],"output":{"name":"bool"}}],[11,"try_drop","","",6,{"inputs":[{"name":"self"},{"name":"guard"}],"output":null}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",7,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"load","","",7,{"inputs":[{"name":"self"},{"name":"guard"}],"output":{"name":"notnull"}}],[11,"replace","","",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"compare_and_set_shared","","",7,{"inputs":[{"name":"self"},{"name":"notnull"},{"name":"notnull"},{"name":"guard"}],"output":{"generics":["notnull"],"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"drop","","",7,{"inputs":[{"name":"self"}],"output":null}],[0,"map_inner","lockfreehashmap","This module implements most of the logic behind the [::LockFreeHashMap].",null,null],[3,"MapInner","lockfreehashmap::map_inner","A map containing a unique, non-resizable array to the Key/Value pairs. If the map needs to be resized, a new `MapInner` must be created and its Key/Value pairs must be copied from this one. Logically, this struct owns its keys and values, and so is responsible for freeing them when dropped.",null,null],[12,"map","","The key/value pairs in this map, allocated as an array of pairs.",8,null],[12,"size","","The amount of key/value pairs in the array, if any.",8,null],[12,"newer_map","","Points to the newer map or null if none.",8,null],[12,"resizers_count","","Any thread can allocate memory to resize the map and create `newer_map`. Thus, we want to try and limit the amount of allocations done. This is a monotonically increasing count of the number of threads currently trying to allocate a new map, which is used as a heuristic. See its use in the `MapInner::create_newer_map()` function.",8,null],[12,"chunks_copied","","The number of `::COPY_CHUNK_SIZE = 32` element chunks that some thread has commited to copying to the newer table. Once this reaches `capacity/COPY_CHUNK_SIZE`, we know that the entire map has been copied into the large `newer_map`.",8,null],[12,"slots_copied","","The actual number of key/value pairs that have been copied into the newer map.",8,null],[12,"hash_builder","","The hasher used to hash keys.",8,null],[4,"KeySlot","","The hash map is implemented as an array of key-value pairs, where each key and value can be one of several states. This enum represents the various states that a key can be in, excluding the null/empty state.",null,null],[13,"Key","","A key has been inserted into table. The key's associated value may or may not have been removed. Once a key is in this state it can't go into any other state.",9,null],[13,"SeeNewTable","","This was an empty slot that is now taken. There is a newer (resized) table that should be used if this key slot was needed. Once a key is in this state it can't go into any other state.",9,null],[4,"ValueSlot","","The hash map is implemented as an array of key-value pairs, where each key and value can be one of several states. This enum represents the various states that a value can be in, excluding the null/empty state.",null,null],[13,"Value","","A value has been inserted into the table.",10,null],[13,"Tombstone","","This state represents that a key has been inserted but then removed.",10,null],[13,"ValuePrime","","The table is being resized currently and the value here still needs to be inserted into the newer table.",10,null],[13,"SeeNewTable","","This state represents one of two things:     1) This was a `ValueSlot::Tombstone(_)` slot that is now taken. There is a newer        (resized) table that should be used if this value slot was needed.     2) This used to be a `ValueSlot::Value(_)` slot that has now been copied into the        newer table. This is the final state for any `ValueSlot`.",10,null],[4,"Match","","Sometimes, when inserting a new value into the hash map, we only want to insert something if the value already matches something.",null,null],[13,"Empty","","Match if there is no key/value pair in the map",11,null],[13,"AnyKeyValuePair","","Match if there is a key/value pair in the map",11,null],[13,"Always","","Always match",11,null],[4,"KeyCompare","","Sometimes when calling `put_if_match()` we want to insert a key and sometimes we just want to compare it with some variable of type `Q`. This enum represents which one is intended.",null,null],[13,"Owned","","",12,null],[13,"Shared","","",12,null],[13,"OnlyCompare","","",12,null],[4,"QRef","","See `KeyCompare::as_qref()` for the motivation behind this type.",null,null],[13,"Shared","","",13,null],[13,"Borrow","","",13,null],[4,"QRef2","","See `KeyCompare::as_qref()` for the motivation behind this type.",null,null],[13,"Shared","","",14,null],[13,"Borrow","","",14,null],[4,"PutValue","","This enum represents the value to insert when calling `put_if_match()`, which is usually owned when called from `LockFreeHashMap` and shared if its been copied from a previous, smaller map.",null,null],[13,"Owned","","",15,null],[13,"Shared","","",15,null],[6,"KVPair","","",null,null],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"valueslot"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"valueslot"}],"output":{"name":"bool"}}],[11,"is_tombstone","","Returns true if and only if the `ValueSlot` has discriminant `Tombstone`.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_valueprime","","Returns true if and only if the `ValueSlot` has discriminant `ValuePrime`.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_value","","Returns true if and only if the `ValueSlot` has discriminant `Value`.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_seenewtable","","Returns true if and only if the `ValueSlot` has discriminant `SeeNewTable`.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_prime","","Returns true if and only if the `ValueSlot` has either discriminant `ValuePrime` or `SeeNewTable`.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_inner","","Return an `Option` reference to the inner value of generic type `V`.",10,{"inputs":[{"name":"option"}],"output":{"name":"option"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",12,{"inputs":[{"name":"k"}],"output":{"name":"self"}}],[11,"as_qref","","The purpose of this function is to ultimately get a value of type `&Q`. Because we need to call `deref()` and `borrow()` a few times, we need to put the result of these functions somewhere in order to return a reference. Thus, `QRef` and `QRef2` are introduced as helper types to place these values somewhere.",12,{"inputs":[{"name":"self"}],"output":{"name":"qref"}}],[11,"as_qref2","","",13,{"inputs":[{"name":"self"}],"output":{"name":"qref2"}}],[11,"as_q","","",14,{"inputs":[{"name":"self"}],"output":{"name":"q"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",15,{"inputs":[{"name":"v"}],"output":{"name":"self"}}],[11,"new_tombstone","","Returns a new `PutValue` containing an owned `ValueSlot::Tombstone` value.",15,{"inputs":[],"output":{"name":"self"}}],[11,"is_tombstone","","Returns true if and only if the inner `ValueSlot` has discriminant `Tombstone`.",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"ptr_equals","","",15,{"inputs":[{"name":"self"},{"generics":["valueslot"],"name":"notnull"}],"output":{"name":"bool"}}],[11,"as_raw","","",15,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[18,"DEFAULT_CAPACITY","","The default size of a new `LockFreeHashMap`.",8,null],[11,"capacity","","Returns the capacity of the current map; i.e. the length of the `Vec` storing the key/value pairs.",8,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","","Returns the size of the current map at some point in time; i.e. the number of key/value pairs in the map.",8,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"drop_newer_maps","","Drops `self.newer_map` and any newer maps that `self.newer_map` points to.",8,{"inputs":[{"name":"self"},{"name":"guard"}],"output":null}],[11,"drop_self_and_newer_maps","","Drops self, `self.newer_map` and any newer maps that `self.newer_map` points to.",8,{"inputs":[{"name":"self"},{"name":"guard"}],"output":null}],[11,"with_capacity","","Creates a new `MapInner`. Uses the next power of two if size is not a power of two.",8,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"with_capacity_and_hasher","","",8,{"inputs":[{"name":"usize"},{"name":"s"}],"output":{"name":"self"}}],[11,"help_copy","","Help copy a small chunk of the map to the `newer_map`. See `::COPY_CHUNK_SIZE` for the default chunk size.",8,{"inputs":[{"name":"self"},{"name":"notnull"},{"name":"bool"},{"name":"atomicbox"},{"name":"guard"}],"output":null}],[11,"promote","","Once a `MapInner` has had all its elements copied to its `newer_map` field, the LockFreeHashMap's `inner` field must be promoted so that its effects are visible globally.",8,{"inputs":[{"name":"self"},{"name":"notnull"},{"name":"atomicbox"},{"name":"guard"}],"output":{"name":"bool"}}],[11,"ensure_slot_copied","","",8,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"atomicbox"},{"name":"guard"}],"output":{"name":"notnull"}}],[11,"try_promote","","",8,{"inputs":[{"name":"self"},{"name":"notnull"},{"name":"usize"},{"name":"atomicbox"},{"name":"guard"}],"output":{"name":"bool"}}],[11,"copy_slot","","Copies a single key/value pair from the map in `&self` to the map in `&self.newer_map`.",8,{"inputs":[{"name":"self"},{"name":"self"},{"name":"usize"},{"name":"atomicbox"},{"name":"guard"}],"output":{"name":"bool"}}],[11,"create_newer_map","","If `newer_map` doesn't exist, then this function tries to allocate a newer map that's double the size of `self`.",8,{"inputs":[{"name":"self"},{"name":"guard"}],"output":{"name":"notnull"}}],[11,"hash_key","","",8,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"usize"}}],[11,"keys_are_equal","","",8,{"inputs":[{"name":"self"},{"name":"t1"},{"name":"t2"}],"output":{"name":"bool"}}],[11,"get","","Returns the current value associated with some key, if any.",8,{"inputs":[{"name":"self"},{"name":"q"},{"name":"atomicbox"},{"name":"guard"}],"output":{"name":"option"}}],[11,"update_size_and_defer","","Increments or decrements the current size of the map, returning the previous value in the map.",8,{"inputs":[{"name":"self"},{"generics":["valueslot"],"name":"maybenull"},{"name":"bool"},{"name":"guard"}],"output":{"generics":["valueslot"],"name":"option"}}],[11,"put_if_match","","",8,{"inputs":[{"name":"self"},{"name":"keycompare"},{"name":"putvalue"},{"name":"match"},{"name":"atomicbox"},{"name":"guard"}],"output":{"generics":["valueslot"],"name":"option"}}],[11,"clone_hasher","","",8,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[11,"drop","","",8,{"inputs":[{"name":"self"}],"output":null}],[17,"COPY_CHUNK_SIZE","lockfreehashmap","",null,null],[18,"DEFAULT_CAPACITY","","The default size of a new `LockFreeHashMap` when created by `LockFreeHashMap::new()`.",2,null],[11,"with_capacity_and_hasher","","Creates an empty `LockFreeHashMap` with the specified capacity, using `hasher` to hash the keys.",2,{"inputs":[{"name":"usize"},{"name":"s"}],"output":{"name":"self"}}],[11,"load_inner","","Private helper method to load the `inner` field as a &[MapInner].",2,{"inputs":[{"name":"self"},{"name":"guard"}],"output":{"name":"mapinner"}}],[11,"capacity","","Returns the number of elements the map can hold without reallocating.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","","Returns the number of elements in the map.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clear","","Clears the entire map.",2,{"inputs":[{"name":"self"}],"output":null}],[11,"clear_with_capacity","","Clears the entire map.",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",2,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"bool"}}],[11,"get","","Returns a reference to the value corresponding to the key. The key may be any borrowed form of the map's key type, but Hash and Eq on the borrowed form must match those for the key type.",2,{"inputs":[{"name":"self"},{"name":"q"},{"name":"guard"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair into the map. If the map did not have this key present, None is returned. If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be `==` without being identical.",2,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"},{"name":"guard"}],"output":{"name":"option"}}],[11,"replace","","Inserts a key-value pair into the map, but only if there is already an existing value that corresponds to the key in the map. If the map did not have this key present, None is returned. If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be `==` without being identical.",2,{"inputs":[{"name":"self"},{"name":"q"},{"name":"v"},{"name":"guard"}],"output":{"name":"option"}}],[11,"remove","","Removes a key from the map, returning the value at the key if the key was previously in the map. The key may be any borrowed form of the map's key type, but Hash and Eq on the borrowed form must match those for the key type.",2,{"inputs":[{"name":"self"},{"name":"q"},{"name":"guard"}],"output":{"name":"option"}}],[11,"new","","Creates a new `LockFreeHashMap`.",2,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Creates a new `LockFreeHashMap` of a given size. Uses the next power of two if size is not a power of two.",2,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"drop","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"defer","","Stores a function so that it can be executed at some point after all currently pinned threads get unpinned.",0,null],[11,"flush","","Clears up the thread-local cache of deferred functions by executing them or moving into the global cache.",0,null],[11,"repin","","Unpins and then immediately re-pins the thread.",0,null],[11,"repin_after","","Temporarily unpins the thread, executes the given function and then re-pins the thread.",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"r"}}],[11,"collector","","Returns the `Collector` associated with this guard.",0,{"inputs":[{"name":"self"}],"output":{"generics":["collector"],"name":"option"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"guard"}}],[11,"drop","","",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"drop","","",1,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"defer","","Schedule code to be executed when exiting the scope.",1,null],[11,"spawn","","Create a scoped thread.",1,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"scopedjoinhandle"}}],[11,"builder","","Generates the base configuration for spawning a scoped thread, from which configuration methods can be chained.",1,{"inputs":[{"name":"self"}],"output":{"name":"scopedthreadbuilder"}}]],"paths":[[3,"Guard"],[3,"Scope"],[3,"LockFreeHashMap"],[3,"NotNull"],[3,"NotNullOwned"],[3,"MaybeNull"],[3,"AtomicPtr"],[3,"AtomicBox"],[3,"MapInner"],[4,"KeySlot"],[4,"ValueSlot"],[4,"Match"],[4,"KeyCompare"],[4,"QRef"],[4,"QRef2"],[4,"PutValue"]]};
initSearch(searchIndex);
